= Input types
include::variables.adoc[]

In the previous {document}, we created a very simple content type and used it to create some content. However, in real world settings, you're likely to going to want to use more complex content types with different kinds of data (such as images). In this {document}  we'll be looking at some of the basic input types that come with XP and what we use them for.

At the end of the {document}, we'll put everything we've learned so far together.

NOTE: This {document} keeps building on what we did in the previous {document}s. You'll need  to have your first app up an deployed to get started. If you haven't got that ready yet, go and have a look at the xref:content[previous chapter].

== Input types overview

XP provides a number of input types for you to work with. This section highlights a few types you'll be using a lot and shows off some of their special features and then mentions some of the types you're also likely to be seeing a lot of. Go to the reference docs for https://developer.enonic.com/docs/xp/stable/cms/input-types[a full list of all input types and their features].

=== TextLine

image::input-type-text-line.png[TextLine: A single-line input field., width=800]

TextLine inputs are useful for short fields that contain text. They're also supports two forms of validation out of the box: max length and regular expressions. They can be used separately or together. The max length validation specifies that a user's input can not be longer than the specified value. The regular expression validation allows you to provide a custom regex that is used to validate the input field as you wish.

NOTE: XP uses JavaScript's regex engine to validate the input. For more information on what kind of of patterns it recognizes, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#writing_a_regular_expression_pattern[MDN's documentation].

For example, an input that only allows between characters from `a` to `z` and requires between one and seventeen characters could look like this:

.A TextLine input type with
[source,xml]
----
<input name="validation-example" type="TextLine">
  <label>TextLine input validation example.</label>
    <config>
      <max-length>17<max-length>
      <regexp>^[a-fA-Z]+$</regexp>
    </config>
</input>
----

Further, if you want to provide a default value for a TextLine input, you can do that by using the `default` configuration option. For an example of how to do this and for more information on the TextLine input, visit the https://developer.enonic.com/docs/xp/stable/cms/input-types#textline[reference docs].

=== ImageSelector

image::input-type-image-selector.png[ImageSelector: An interactive image selection tool., width=800]

Images are a key part of many web experiences: they add color, break up the content, and gives the reader something to rest their eyes on. XP's image selector allows you to select an image for a piece of content and also to upload new images.

In XP, image selectors are great for when you want to associate one or more images with piece of content. For instance, if you're creating an animal data set, you might want to have an image of what each animal looks like both as a young and as an adult.

.An minimal ImageSelector configuration
[source,xml]
----
<input name="myimage" type="ImageSelector">
  <label>My Image</label>
</input>
----

Read more about the https://developer.enonic.com/docs/xp/stable/cms/input-types#imageselector[configuration of image selectors] in the reference docs.

=== Content Selector

image::input-type-content-selector.png[ContentSelector: An interactive content selection tool., width=800]

The image selector we just saw is actually a specialized form of the more complex ContentSelector input type. The ContentSelector input type allows you to reference other content. Let's say you have two content types: one of type person and one of type food. If you want to be able to specify which dishes the person likes, you could use a content type to create a reference from the person to their favored dish.

Because referencing other content types comes with a lot of variability, the ContentSelector type has configuration options to support this. You can choose to allow only certain content types or only content that's available at a certain path. You can also change how the selector is presented to the user, including how it should present available content to the user and whether it should list content status.

https://developer.enonic.com/docs/xp/stable/cms/input-types#contentselector[The full list of ContentSelector configuration options] is available in the reference docs, including a number of examples to explain content inclusion and exclusion. However, a simple configuration could look like this:

.A basic ContentSelector configuration that only allows one content type
[source, xml]
----
<input name="mycontentselector" type="ContentSelector">
  <label>My ContentSelector</label>
  <config>
    <allowContentType>citation</allowContentType>
  </config>
</input>
----

=== More useful input types

Some other very useful input types that it's worth looking into are:

https://developer.enonic.com/docs/xp/stable/cms/input-types#checkbox[CheckBox]:: A trusty input checkbox. Indicates whether something is in one of two states.
https://developer.enonic.com/docs/xp/stable/cms/input-types#combobox[ComboBox]:: A dropdown menu containing predefined options for the user to select from. Allows selection of one or more options.
https://developer.enonic.com/docs/xp/stable/cms/input-types#date[Date] and https://developer.enonic.com/docs/xp/stable/cms/input-types#datetime[DateTime]:: Provides an interactive date picker (with a time component in DateTime's case) to save date and times.
https://developer.enonic.com/docs/xp/stable/cms/input-types#geopoint[GeoPoint]:: Stores GPS coordinates.
https://developer.enonic.com/docs/xp/stable/cms/input-types#htmlarea[HtmlArea]:: Provides a rich text, multi-line input. We'll discuss this in detail in xref:rich-text[the next {document}].
https://developer.enonic.com/docs/xp/stable/cms/input-types#textarea[TextArea]:: Provides a multi-line text input with optional max length.

== Input type configuration

In the work we did in the previous {document}, we did some very minor configuration of the input types. In the sections above, we have seen a little more of what you can do, such as adding validation and specifying what formatting features the user should get.

All input types share the same configuration options. In the XML schema, these configuration options go directly under the `input` tag. Additionally, the `config` tag can hold input-specific configuration.

These full list of available configuration options is:

`label` (required):: What the input should be labeled as in the content form.
`occurrences` (optional):: Specifies whether this input is required to be filled out, and whether it's a list or not.
`default` (optional):: Gives a default value to the input.
`help-text` (optional):: Lets you specify a description of the input field to show to the user.
`config` (optional):: Input type-specific configuration.
+
Each input type also takes an optional `config` element for extra configuration. Because the input types are so different to each other, they all support different options. This is what allows us to use regex validation for TextLine inputs, configure formatting options for HtmlAreas, and what numeric values a Long or a Double input accepts.
+
To find out exactly what configuration options an input type accepts and how to configure it, visit https://developer.enonic.com/docs/xp/stable/cms/input-types[the input types documentation].

All of these configuration options are described in more detail in the https://developer.enonic.com/docs/xp/stable/cms/schemas#input_types[input types schema documentation], so head over there for more information and explanation of how the various inputs work. As a bonus,

=== Validation

Enonic also provides XML Schema Definitions (XSDs) for text editor integration and validation of your XML schemas. To use it, add the attribute `xmlns`, `xmlns:xsi`, and `xsi:schemaLocation` to your content-type as shown below:

.Using XSDs for schema validation of a content type definition.
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type
    xmlns="urn:enonic:xp:model:1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:enonic:xp:model:1.0 https://raw.githubusercontent.com/enonic/xp/master/modules/core/core-api/src/main/resources/META-INF/xsd/model.xsd">
  <display-name>person</display-name>
  <!-- rest of content elided for brevity -->
</content-type>
----

Note that in-editor schema validation depends on whether your text editor supports validating against XSD schemas or not.

== Task: {content-type-1}s and pets

Time for a little recap! We'll put together everything we've learned about content types and input types thus far to create a new data set. A solution is listed below, but try and see if you can solve it yourself first. If you're wondering how to achieve some of the goals, try consulting the documentation that's been linked to in this {document}.

Your task is to create a new content type: `{content-type-2-capitalized}` and to update the `{content-type-1-capitalized}` content type with new constraints and fields.

An {content-type-2} should have the following inputs:

. Its name, e.g. "elephant". Each {content-type-2} must have at least one name, but multiple are also okay. For instance, the reindeer is also known as caribou.
. A multi-line text input for adding a description of the animal. It should allow at most 500 characters.
. An image selector that accepts between 0 and 3 images.
. Help text where you think it would be helpful.

When you've created the content type, create a new folder in Content Studio at next to the {content-type-1}s folder. Call it "{content-type-2}s".

For the {content-type-1} content type, here's what's going to change:

. Allow each {content-type-1} to have any number of aliases. (Hint: use the occurrences element; check the documentation for how it works.)
. Add a ContentSelector input that allows only content of the "{content-type-2-capitalized}" type and that must be nested under the site's "{content-type-2}s" folder. Call it `favorite{content-type-2-capitalized}`.
. Make the "name" field required.

To verify that everything works, create some animals, and try creating a content link between a {content-type-1} and an {content-type-2}.

When you've got that, create a GraphQL query that'll fetch all {content-type-1}s and list what their favorite animals are, as well their animals' descriptions .

=== Solution

First, we'll create the animal content type. In `src/main/resources/site/content-types/{content-type-2}/{content-type-2}.xml`, place the following content:

.The {content-type-2} content type
[source,xml]
----
<content-type>
  <display-name>Animal</display-name>
  <description>An animal that lives on the planet Earth</description>
  <super-type>base:structured</super-type>
  <form>
    <input name="name" type="TextLine">
      <label>Name</label>

      <help-text>Put the name of the animal here. You can be as
      specific or as vague as you like. "Dog" is just as good as
      "Canis lupus familiaris".</help-text> <!--1-->
    </input>

    <input name="description" type="TextArea" >
      <label>Description</label>
      <help-text>Describe the animal. Where its habitats are, what it
      eats, etc.</help-text>
      <config>
        <max-length>500</max-length>
      </config>
    </input>

    <input name="images" type="ImageSelector">
      <label>Images</label>
      <help-text>Images of the animal</help-text>
      <occurrences minimum="0" maximum="3"/> <!--2-->
    </input>

  </form>
</content-type>
----

<1> This help text explains what we want in the "name" field, in case the user wants more information.
<2> Using the `occurrences` element, we specify that the user can supply between zero and three images.

Next, we'll update the `{content-type-1-capitalized}` content type.

.An updated {content-type-1}
[source,xml]
----
<content-type>
  <display-name>person</display-name>
  <description>A description of a person</description>
  <display-name-expression>${name} (${alias})</display-name-expression>
  <super-type>base:structured</super-type>
  <form>

    <input name="name" type="TextLine">
      <label>Name</label>
      <occurrences minimum="1" maximum="1" /> <!--1-->
    </input>

    <input name="alias" type="TextLine">
      <label>Alias</label>
      <occurrences minimum="0" maximum="0" /> <!--2-->
    </input>

    <input name="favoriteAnimal" type="ContentSelector"> <!--3-->
      <label >Favorite animal</label>
      <config>
        <allowContentType>animal</allowContentType>
        <allowPath>${site}/animals/</allowPath>
      </config>
    </input>

  </form>
</content-type>
----

<1> To make a field required, set both `minimum` and `maximum` attributes of the `occurrences` tag to 0.
<2> Setting `maximum="0"` on an `occurrences` is how you indicate that there is no upper limit to how many occurrences a field can have.
<3> This ContentSelector uses the `config` section to narrow the possible types of content to only be `{content-type-2-capitalized}`

Nice! Now, go and create some {content-type-2}s. Either pick your favorites, or, if you're not feeling creative, add these (content from Wikipedia), :

.Lion (https://en.wikipedia.org/wiki/Lion[Wiki article for lion])
Name:: Lion
Description:: The lion (Panthera leo) is a species in the family Felidae and a member of the genus Panthera. It has a muscular, deep-chested body, short, rounded head, round ears, and a hairy tuft at the end of its tail.

.Reindeer (https://en.wikipedia.org/wiki/Reindeer[Wiki article for reindeer])
Name:: Reindeer, Caribou
Description:: The reindeer (Rangifer tarandus), also known as caribou in North America, is a species of deer with circumpolar distribution, native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America.

Now create some links using ContentSelector from {content-type-1}s to {content-type-2}s. The important part here is that you link some content so that we can fetch it using GraphQL. When you have created some links, let's move on to the query.

The way to link to linked content in GraphQL is to add it as a field as part of the data. This query will fetch all {content-type-1}s and their linked {content-type-2}s:

.Query to fetch {content-type-1}s with their associated favorite animals
[source,GraphQL]
----
{
  guillotine {
    getChildren(key: "/my-first-site/{content-type-1}s/")
    {
      displayName
      ... on {project-name-query}_{content-type-1-capitalized} {
        data {
          name
          alias
          favoriteAnimal {
            displayName
            ... on {project-name-query}_Animal{
              data {
                name
                description
              }
            }
          }
        }
      }
    }
  }
}
----

Depending on the links (and {content-type-2}s) you created, your result might look a little something like this:

.The list of {content-type-1}s with their favorite animals
[source,json]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Cardi B",
          "data": {
            "name": "Belcalis Marlenis Alm√°nzar",
            "alias": [
              "Cardi B"
            ],
            "favoriteAnimal": {
              "displayName": "Lion",
              "data": {
                "name": [
                  "Lion"
                ],
                "description": "The lion (Panthera leo) is a species in the family Felidae and a member of the genus Panthera. It has a muscular, deep-chested body, short, rounded head, round ears, and a hairy tuft at the end of its tail."
              }
            }
          }
        },
        {
          "displayName": "Missy Elliott",
          "data": {
            "name": "Melissa Arnette Elliott",
            "alias": [
              "Missy Elliott"
            ],
            "favoriteAnimal": {
              "displayName": "Reindeer",
              "data": {
                "name": [
                  "Reindeer",
                  "Caribou"
                ],
                "description": "The reindeer (Rangifer tarandus), also known as caribou in North America, is a species of deer with circumpolar distribution, native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America."
              }
            }
          }
        },
        {
          "displayName": "P!nk",
          "data": {
            "name": "Alecia Beth Moore",
            "alias": [
              "P!nk"
            ],
            "favoriteAnimal": {
              "displayName": "Reindeer",
              "data": {
                "name": [
                  "Reindeer",
                  "Caribou"
                ],
                "description": "The reindeer (Rangifer tarandus), also known as caribou in North America, is a species of deer with circumpolar distribution, native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America."
              }
            }
          }
        }
      ]
    }
  }
}
----

== Next

The next {document} is dedicated to rich text editing using the HtmlArea input type. The HtmlArea has a lot of knobs to twist and turn, so it's worth getting to know it properly.
