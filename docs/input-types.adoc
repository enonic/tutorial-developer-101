= Input types
include::variables.adoc[]

In the previous {document}, we created a very simple content type and used it to create some content. However, in real world settings, you're likely to going to want to use more complex content types with different kinds of data (such as images). In this {document}  we'll be looking at some of the basic input types that come with XP and what we use them for.

At the end of the {document}, we'll put everything we've learned so far together.

NOTE: This {document} keeps building on what we did in the previous {document}s. You'll need  to have your first app up an deployed to get started. If you haven't got that ready yet, go and have a look at the xref:content[previous chapter].

== Input types overview

XP provides a number of input types for you to work with. This section highlights a few types you'll be using a lot and shows off some of their special features and then mentions some of the types you're also likely to be seeing a lot of. Go to the reference docs for https://developer.enonic.com/docs/xp/stable/cms/input-types[a full list of all input types and their features].

=== TextLine

image::input-type-text-line.png[TextLine: A single-line input field., width=800]

TextLine inputs are useful for short fields that contain text. They also support two forms of validation out of the box: max length and regular expressions. They can be used separately or together. The max length validation specifies that a user's input can not be longer than the specified value. The regular expression validation allows you to provide a custom regex that is used to validate the input field as you wish.

NOTE: XP uses JavaScript's regex engine to validate the input. For more information on what kind of of patterns it recognizes, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#writing_a_regular_expression_pattern[MDN's documentation].

.A simple TextLine input type with a max-length
[source,xml]
----
<input name="validation-example" type="TextLine">
  <label>TextLine input validation example.</label>
    <config>
      <max-length>42<max-length>
    </config>
</input>
----

Further, if you want to provide a default value for a TextLine input, you can do that by using the `default` configuration option. For an example of how to do this and for more information on the TextLine input, visit the https://developer.enonic.com/docs/xp/stable/cms/input-types#textline[reference docs].

=== ImageSelector

image::input-type-image-selector.png[ImageSelector: An interactive image selection tool., width=800]

Images are a key part of many web experiences: they add color, break up the content, and gives the reader something to rest their eyes on. XP's image selector allows you to select an image for a piece of content and also to upload new images.

In XP, image selectors are great for when you want to associate one or more images with piece of content. For instance, if you're creating an animal data set, you might want to have an image of what each animal looks like both as a young and as an adult.

.An minimal ImageSelector configuration
[source,xml]
----
<input name="myimage" type="ImageSelector">
  <label>My Image</label>
</input>
----

Read more about the https://developer.enonic.com/docs/xp/stable/cms/input-types#imageselector[configuration of image selectors] in the reference docs.

==== Working with images

TODO

=== Content Selector

image::input-type-content-selector.png[ContentSelector: An interactive content selection tool., width=800]

The image selector we just saw is actually a specialized form of the more complex ContentSelector input type. The ContentSelector input type allows you to reference other content. Let's say you have two content types: one of type person and one of type food. If you want to be able to specify which dishes the person likes, you could use a content type to create a reference from the person to their favored dish.

Because referencing other content types comes with a lot of variability, the ContentSelector type has configuration options to support this. You can choose to allow only certain content types or only content that's available at a certain path. You can also change how the selector is presented to the user, including how it should present available content to the user and whether it should list content status.

https://developer.enonic.com/docs/xp/stable/cms/input-types#contentselector[The full list of ContentSelector configuration options] is available in the reference docs, including a number of examples to explain content inclusion and exclusion. However, a simple configuration could look like this:

.A basic ContentSelector configuration that only allows one content type
[source, xml]
----
<input name="mycontentselector" type="ContentSelector">
  <label>My ContentSelector</label>
  <config>
    <allowContentType>citation</allowContentType>
  </config>
</input>
----

=== More useful input types

Some other very useful input types that it's worth looking into are:

https://developer.enonic.com/docs/xp/stable/cms/input-types#checkbox[CheckBox]:: A trusty input checkbox. Indicates whether something is in one of two states.
https://developer.enonic.com/docs/xp/stable/cms/input-types#combobox[ComboBox]:: A dropdown menu containing predefined options for the user to select from. Allows selection of one or more options.
https://developer.enonic.com/docs/xp/stable/cms/input-types#date[Date] and https://developer.enonic.com/docs/xp/stable/cms/input-types#datetime[DateTime]:: Provides an interactive date picker (with a time component in DateTime's case) to save date and times.
https://developer.enonic.com/docs/xp/stable/cms/input-types#geopoint[GeoPoint]:: Stores GPS coordinates.
https://developer.enonic.com/docs/xp/stable/cms/input-types#htmlarea[HtmlArea]:: Provides a rich text, multi-line input. We'll discuss this in detail in xref:rich-text[the next {document}].
https://developer.enonic.com/docs/xp/stable/cms/input-types#textarea[TextArea]:: Provides a multi-line text input with optional max length.

== Input type configuration

In the work we did in the previous {document}, we did some very minor configuration of the input types. In the sections above, we have seen a little more of what you can do, such as adding validation and specifying what formatting features the user should get.

All input types share the same configuration options. In the XML schema, these configuration options go directly under the `input` tag. Additionally, the `config` tag can hold input-specific configuration.

These full list of available configuration options is:

`label` (required):: What the input should be labeled as in the content form.
`occurrences` (optional):: Specifies the minimum and maximum instances of this field. Defaults to "one optional".
`default` (optional):: Gives a default value to the input.
`help-text` (optional):: Lets you specify a description of the input field to show to the user.
`config` (optional):: Input type-specific configuration.
+
Each input type also takes an optional `config` element for extra configuration. Because the input types are so different to each other, they all support different options. This is what allows us to use regex validation for TextLine inputs, configure formatting options for HtmlAreas, and what numeric values a Long or a Double input accepts.
+
To find out exactly what configuration options an input type accepts and how to configure it, visit https://developer.enonic.com/docs/xp/stable/cms/input-types[the input types documentation].

All of these configuration options are described in more detail in the https://developer.enonic.com/docs/xp/stable/cms/schemas#input_types[input types schema documentation], so head over there for more information and explanation of how the various inputs work. As a bonus,

== Task: {content-type-1}s and {content-type-2}s

Time for a little recap! We'll put together everything we've learned about content types and input types thus far to create a new data set. A solution is listed below, but try and see if you can solve it yourself first. If you're wondering how to achieve some of the goals, try consulting the documentation that's been linked to in this {document}.

Your task is to create a new content type: `{content-type-2-capitalized}` and to update the `{content-type-1-capitalized}` content type with new constraints and fields. By the end of this {document}, you should have content types that look like this in Content Studio:

.The target for this task: {content-type-2} and {content-type-1}
image::{content-type-2}-and-{content-type-1}-target.png["An {content-type-2} content wizard next to an {content-type-1} wizard"]

An {content-type-2} should have the following inputs:

. Use its species name, e.g. "elephant", as its display name. Use the `display-name-label` element to label it as "species" (hint: see https://developer.enonic.com/docs/xp/stable/cms/content-types#form_definition[the content type form definition] for info on how to use `display-name-label`).
. An {content-type-2} can also have alternative names for its species (for instance, the reindeer is also known as caribou). Allow the user to add as many alternative names as they want.
. An image selector that accepts between 0 and 3 images.
. Help text where you think it would be helpful.

When you've created the content type, create a new folder in Content Studio at next to the {content-type-1}s folder. Call it "{content-type-2}s".

For the {content-type-1} content type, here's what's going to change:

. Add a ContentSelector input that allows only content of the "{content-type-2-capitalized}" type and that must be nested under the site's "{content-type-2}s" folder. Call it `favorite{content-type-2-capitalized}`.

To verify that everything works, create some animals, and try creating a content link between a {content-type-1} and an {content-type-2}.

When you've got that, create a GraphQL query that'll fetch all {content-type-1}s and list what their favorite animals are, as well their animals' descriptions .

=== Solution

First, we'll create the animal content type. In `src/main/resources/site/content-types/{content-type-2}/{content-type-2}.xml`, place the following content:

.The {content-type-2} content type
[source,xml,subs={subs}]
----
<content-type>
  <display-name>{content-type-2-capitalized}</display-name>
  <description>An {content-type-2} that lives on planet Earth</description>
  <display-name-label>Species</display-name-label> <!--.-->
  <super-type>base:structured</super-type>
  <form>

    <input type="TextLine" name="otherNames">
      <label>Other names</label>
      <help-text>Other names for this species.</help-text> <!--.-->
      <occurrences minimum="0" maximum="0" /> <!--.-->
    </input>

    <input name="images" type="ImageSelector">
      <label>Images</label>
      <help-text>Images of the animal</help-text>
      <occurrences minimum="0" maximum="3" /> <!--.-->
    </input>

  </form>
</content-type>
----

<.> This field lets you customize what Content Studio calls the "display name" field and what it puts in the placeholder text.
<.> This help text explains what we want in the "name" field, in case the user wants more information.
<.> The `occurrences` element specifies how many occurrences a field can have. Setting `maximum="0"` is how you indicate that there is no upper limit to how many occurrences a field can have.
<.> This `occurrences` element specifies that the user can supply between zero and three images.

Next, we'll update the `{content-type-1-capitalized}` content type.

.An updated {content-type-1}
[source,xml,subs={subs}]
----
<content-type>
  <display-name>{content-type-1-capitalized}</display-name>
  <description>Information about an {content-type-1}</description>
  <super-type>base:structured</super-type>
  <form>

    <input name="name" type="TextLine">
      <label>Name</label>
      <help-text>
        The artist's name (if different from their professional moniker).
      </help-text>
    </input>

    <input type="TextArea" name="about">
      <label>About the {content-type-1}</label>
    </input>

    <input name="favoriteAnimal" type="ContentSelector"> <!--.-->
      <label>Favorite animal</label>
      <config>
        <allowContentType>animal</allowContentType>
        <allowPath>${site}/animals/</allowPath>
      </config>
    </input>

  </form>
</content-type>
----

<.> This ContentSelector uses the `config` section to narrow the possible types of content to only be `{content-type-2-capitalized}`

Nice! Now, go and create some {content-type-2}s. Either pick your favorites, or, if you're not feeling creative, add these (content from Wikipedia), :

.Lion (https://en.wikipedia.org/wiki/Lion[Wiki article for lion])
Name:: Lion
Description:: The lion (Panthera leo) is a species in the family Felidae and a member of the genus Panthera. It has a muscular, deep-chested body, short, rounded head, round ears, and a hairy tuft at the end of its tail.

.Reindeer (https://en.wikipedia.org/wiki/Reindeer[Wiki article for reindeer])
Name:: Reindeer, Caribou
Description:: The reindeer (Rangifer tarandus), also known as caribou in North America, is a species of deer with circumpolar distribution, native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America.

Now create some links using ContentSelector from {content-type-1}s to {content-type-2}s. The important part here is that you link some content so that we can fetch it using GraphQL (remember: you'll find the playground at {p1-api-url}). When you have created some links, let's move on to the query.

The way to link to linked content in GraphQL is to add it as a field as part of the data. This query will fetch all {content-type-1}s and their linked {content-type-2}s:

.Query to fetch {content-type-1}s with their associated favorite animals
[source,GraphQL,subs={subs}]
----
{
  guillotine {
    getChildren(key: "{p1-site-path}/{content-type-1}s/")
    {
      displayName
      ... on {project-name-query}_{content-type-1-capitalized} {
        data {
          name
          favoriteAnimal {
            displayName
            ... on {project-name-query}_{content-type-2-capitalized}{
              data {
                otherNames
                images
              }
            }
          }
        }
      }
    }
  }
}
----

Depending on the links (and {content-type-2}s) you created, your result might look a little something like this:

.The list of {content-type-1}s with their favorite animals
[source,json]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Cardi B",
          "data": {
            "name": "Belcalis Marlenis Alm√°nzar",
            "favoriteAnimal": {
              "displayName": "Reindeer",
              "data": {
                "otherNames": [
                  "Caribou"
                ],
                "images": [
                  {
                    "_path": "/my-first-site/animals/reindeer/reindeer.jpg"
                  }
                ]
              }
            }
          }
        },
        {
          "displayName": "Missy Elliott",
          "data": {
            "name": "Melissa Arnette Elliott",
            "favoriteAnimal": {
              "displayName": "Lion",
              "data": {
                "otherNames": [],
                "images": [
                  {
                    "_path": "/my-first-site/animals/lion/female-lion.jpg"
                  },
                  {
                    "_path": "/my-first-site/animals/lion/male-lion.jpg"
                  }
                ]
              }
            }
          }
        },
        {
          "displayName": "P!nk",
          "data": {
            "name": "Alecia Beth Moore",
            "favoriteAnimal": {
              "displayName": "Reindeer",
              "data": {
                "otherNames": [
                  "Caribou"
                ],
                "images": [
                  {
                    "_path": "/my-first-site/animals/reindeer/reindeer.jpg"
                  }
                ]
              }
            }
          }
        }
      ]
    }
  }
}
----

== Next

The next {document} is dedicated to rich text editing using the HtmlArea input type. The HtmlArea has a lot of knobs to twist and turn, so it's worth getting to know it properly.
